# 36. 有效的数独

- 题目标签：数组, 哈希表, 矩阵
- 难度级别：中等

## 题目描述

请你判断一个 `9 x 9` 的数独是否有效。只需要**根据以下规则**，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

注意：

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 空白格用 `'.'` 表示。

- 示例 1：

  ![数独示例1](./images/250px-sudoku-by-l2g-20050714svg.png)

  ```txt
  输入：board =
  [["5","3",".",".","7",".",".",".","."]
  ,["6",".",".","1","9","5",".",".","."]
  ,[".","9","8",".",".",".",".","6","."]
  ,["8",".",".",".","6",".",".",".","3"]
  ,["4",".",".","8",".","3",".",".","1"]
  ,["7",".",".",".","2",".",".",".","6"]
  ,[".","6",".",".",".",".","2","8","."]
  ,[".",".",".","4","1","9",".",".","5"]
  ,[".",".",".",".","8",".",".","7","9"]]
  输出：true
  ```

- 示例 2：

  ```txt
  输入：board =
  [["8","3",".",".","7",".",".",".","."]
  ,["6",".",".","1","9","5",".",".","."]
  ,[".","9","8",".",".",".",".","6","."]
  ,["8",".",".",".","6",".",".",".","3"]
  ,["4",".",".","8",".","3",".",".","1"]
  ,["7",".",".",".","2",".",".",".","6"]
  ,[".","6",".",".",".",".","2","8","."]
  ,[".",".",".","4","1","9",".",".","5"]
  ,[".",".",".",".","8",".",".","7","9"]]
  输出：false
  解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
  ```

提示：

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j] 是一位数字（1-9）或者 '.'`

## 题解

解题思路：

1. 新建三个数组，初始都使用 `0` 填充成对应：
   1. 行：9 行 9 数字
   2. 列：9 列 9 数字
   3. 小盒子：3 行 3 列 9 数字
2. 遍历矩阵，如果发现：`行数字 || 列数字 || 小盒子数字` 出现重复，返回 `false`
3. 矩阵遍历完成说明没有发现重复情况，返回 `true`

解题代码：

```ts
function isValidSudoku(board: string[][]): boolean {

  const rows = new Array(9).fill(0).map(() => new Array(9).fill(0))
  const cols = new Array(9).fill(0).map(() => new Array(9).fill(0))
  const boxes = new Array(3).fill(0).map(() => new Array(3).fill(0).map(() => new Array(9).fill(0)))

  for (let i = 0; i < 9; i++) {
    for (let j = 0; j < 9; j++) {
      const n = board[i][j].charCodeAt(0) - '0'.charCodeAt(0) - 1

      if (n < 0) {
        continue
      }

      rows[i][n]++
      cols[j][n]++
      boxes[Math.floor(i / 3)][Math.floor(j / 3)][n]++

      if (rows[i][n] > 1
        || cols[j][n] > 1
        || boxes[Math.floor(i / 3)][Math.floor(j / 3)][n] > 1) {

        return false
      }
    }
  }

  return true
}
```
