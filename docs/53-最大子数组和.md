# 53. 最大子数组和

- 题目标签：数组, 分治, 动态规划
- 难度级别：简单

## 题目描述

给你一个整数数组 `nums`，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**是数组中的一个连续部分。

- 示例 1：

  ```txt
  输入：nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
  输出：6
  解释：连续子数组 [4, -1, 2, 1] 的和最大，为 6。
  ```

- 示例 2：

  ```txt
  输入：nums = [1]
  输出：1
  ```

- 示例 3：

  ```txt
  输入：nums = [5, 4, -1, 7, 8]
  输出：23
  ```

## 题解

这套题是一个经典的**动态规划**题目，求解动态规划题目**首先找到题目的子问题，再通过子问题找到状态转移公式**。

求**最大子数组和**这道题的子问题是：

1. 数组当前项值 + 前面的最优解（初始 = 0）
   1. 如果「前面的最优解」> 0，「当前最优解」=「数组当前项」+「前面的最优解」
   2. 否则「当前最优解」= 「数组当前项」
2. 最后，找出所有「当前最优解」中的最大值

如下图所示：

| 索引 0 | 索引 1 | 索引 2 | 索引 3 | 索引 4 | 索引 5 | 索引 6 | 索引 7 | 索引 8 |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| -2     | 1      | -3     | 4      | -1     | 2      | 1      | -5     | 4      |
| -2     | 1      | -2     | 4      | 3      | 5      | 6      | -1     | 4      |

```js
var maxSubArray = function (nums) {
  for (let i = 1; i < nums.length; i++) {
    nums[i] = Math.max(nums[i], nums[i] + nums[i - 1])
  }

  return Math.max(...nums)
}
```
